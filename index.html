<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f14" />
  <title>Romaji → かなカナ (FF TTS Patch)</title>
  <style>
    :root{--bg:#0b0f14;--panel:#111824;--muted:#152033;--text:#e8eef7;--sub:#a8b3c5;--acc:#7aa2ff;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444;--radius:16px;--pad:16px;--tap:44px}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,'Noto Sans',sans-serif}
    header{padding:20px var(--pad) 10px;display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700}
    header .badge{background:var(--muted);padding:6px 10px;border-radius:999px;color:var(--sub);font-size:12px}
    .container{padding:var(--pad);max-width:900px;margin:0 auto}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:.5rem 0}
    textarea{width:100%;min-height:260px;background:#0a1220;color:var(--text);border:1px solid #1f2a3a;border-radius:12px;padding:14px;font-size:18px;line-height:1.7;resize:vertical}
    button,select{appearance:none;border:1px solid #293241;background:#0f1725;color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;min-height:var(--tap)}
    button.primary{background:linear-gradient(180deg,#486bff,#3a57d6);border:none}
    button.success{background:linear-gradient(180deg,#16a34a,#15803d);border:none}
    button:disabled{opacity:.6;cursor:not-allowed}
    .hint{color:var(--sub);font-size:12px}
    .status{font-size:12px;color:var(--sub)}
  </style>
</head>
<body>
  <header><h1>Romaji → ひらがな / カタカナ</h1><span class="badge">Firefox TTS Patch</span></header>
  <div class="container">
    <p>Inline conversion (same textbox). TTS included</p>

    <div class="row">
      <label for="mode" class="hint">Mode</label>
      <select id="mode" aria-label="Conversion mode">
        <option value="hiragana">Hiragana</option>
        <option value="katakana">Katakana</option>
        <option value="none">None</option>
      </select>
      <button id="ttsInit" class="primary" aria-pressed="false" aria-label="Enable speech">Enable Speech</button>
      <button id="speak" aria-label="Speak" disabled>Speak</button>
      <select id="voice" aria-label="Voice" style="max-width:50ch"></select>
    </div>
    <div class="status" id="ttsStatus">Speech: Locked (tap Enable)</div>

    <textarea id="input" placeholder="Type romaji here..."></textarea>
    <div class="hint">Tips: double consonants → っ, 'n' before non-vowel → ん, digraphs like sha/kyo/chu supported.</div>
  </div>

  <script>
    const input = document.getElementById('input');
    const mode  = document.getElementById('mode');
    const speakBtn = document.getElementById('speak');
    const ttsInitBtn = document.getElementById('ttsInit');
    const voiceSel = document.getElementById('voice');
    const ttsStatus = document.getElementById('ttsStatus');

    // =============================================================
    // INLINE CONVERSION (Caret-safe + IME-safe)
    // =============================================================
    const MAP = {
      kya:"きゃ",kyu:"きゅ",kyo:"きょ", gya:"ぎゃ",gyu:"ぎゅ",gyo:"ぎょ",
      sha:"しゃ",shu:"しゅ",sho:"しょ", ja:"じゃ",ju:"じゅ",jo:"じょ",
      cha:"ちゃ",chu:"ちゅ",cho:"ちょ", nya:"にゃ",nyu:"にゅ",nyo:"にょ",
      hya:"ひゃ",hyu:"ひゅ",hyo:"ひょ", mya:"みゃ",myu:"みゅ",myo:"みょ",
      rya:"りゃ",ryu:"りゅ",ryo:"りょ", bya:"びゃ",byu:"びゅ",byo:"びょ",
      pya:"ぴゃ",pyu:"ぴゅ",pyo:"ぴょ",
      shi:"し", chi:"ち", tsu:"つ", fu:"ふ", ji:"じ", di:"ぢ", du:"づ",
      a:"あ", i:"い", u:"う", e:"え", o:"お",
      ka:"か",ki:"き",ku:"く",ke:"け",ko:"こ",
      ga:"が",gi:"ぎ",gu:"ぐ",ge:"げ",go:"ご",
      sa:"さ",si:"し",su:"す",se:"せ",so:"そ",
      za:"ざ",zi:"じ",zu:"ず",ze:"ぜ",zo:"ぞ",
      ta:"た",ti:"ち",tu:"つ",te:"て",to:"と",
      da:"だ",de:"で",do:"ど",
      na:"な",ni:"に",nu:"ぬ",ne:"ね",no:"の",
      ha:"は",hi:"ひ",he:"へ",ho:"ほ",
      ba:"ば",bi:"び",bu:"ぶ",be:"べ",bo:"ぼ",
      pa:"ぱ",pi:"ぴ",pu:"ぷ",pe:"ぺ",po:"ぽ",
      ma:"ま",mi:"み",mu:"む",me:"め",mo:"も",
      ya:"や",yu:"ゆ",yo:"よ",
      ra:"ら",ri:"り",ru:"る",re:"れ",ro:"ろ",
      wa:"わ",wi:"うぃ",we:"うぇ",wo:"を",
      fa:"ふぁ",fi:"ふぃ",fe:"ふぇ",fo:"ふぉ",
      va:"ゔぁ",vi:"ゔぃ",vu:"ゔ",ve:"ゔぇ",vo:"ゔぉ",
      xa:"ぁ",xi:"ぃ",xu:"ぅ",xe:"ぇ",xo:"ぉ",
      xya:"ゃ",xyu:"ゅ",xyo:"ょ", xtu:"っ", ltu:"っ",
      n:"ん"
    };
    const VOWELS = new Set(['a','i','u','e','o']);
    function isLetter(c){ return /^[a-z]$/i.test(c); }
    function isConsonant(c){ return isLetter(c) && !VOWELS.has(c.toLowerCase()); }

    function romajiToHiragana(s){
      s = (s||'').toLowerCase();
      let out = '';
      let i = 0;
      while (i < s.length) {
        const c = s[i];
        if (!/[a-z]/.test(c)) { out += s[i++]; continue; }
        if (i+1 < s.length && s[i] === s[i+1] && isConsonant(s[i]) && s[i] !== 'n') {
          out += 'っ'; i += 1; continue;
        }
        if (c === 'n') {
          const nxt = s[i+1];
          if (!nxt || (!VOWELS.has(nxt) && nxt !== 'y')) { out += 'ん'; i += 1; continue; }
        }
        const tri = s.slice(i, i+3);
        const bi  = s.slice(i, i+2);
        const si  = s.slice(i, i+1);
        if (MAP[tri]) { out += MAP[tri]; i += 3; continue; }
        if (MAP[bi])  { out += MAP[bi];  i += 2; continue; }
        if (MAP[si])  { out += MAP[si];  i += 1; continue; }
        out += s[i]; i += 1;
      }
      return out;
    }

    function toKatakanaFromHiragana(h){
      return h.replace(/[ぁ-ゖ]/g, ch => String.fromCharCode(ch.charCodeAt(0) + 0x60));
    }

    let composing = false;
    function convertAll(text, m){
      if (m === 'none') return text;
      const hira = romajiToHiragana(text);
      return m === 'katakana' ? toKatakanaFromHiragana(hira) : hira;
    }
    function convertPrefixLen(text, caret, m){
      const prefix = text.slice(0, caret);
      return convertAll(prefix, m).length;
    }
    function update(){
      const m = mode.value;
      const before = input.value;
      const start = input.selectionStart, end = input.selectionEnd;
      const converted = convertAll(before, m);
      const newStart = convertPrefixLen(before, start, m);
      const newEnd   = convertPrefixLen(before, end,   m);
      if (before !== converted) input.value = converted;
      try { input.setSelectionRange(newStart, newEnd); } catch {}
    }

    input.addEventListener('compositionstart', ()=>{ composing = true; });
    input.addEventListener('compositionend',  ()=>{ composing = false; update(); });
    input.addEventListener('input', ()=>{ if (!composing) update(); });
    input.addEventListener('paste', ()=>{ setTimeout(()=>{ if (!composing) update(); }, 0); });
    mode.addEventListener('change', update);

    // =============================================================
    // TEXT-TO-SPEECH (Firefox-friendly unlock + fallback)
    // =============================================================
    let voices = [];
    let voicesReady = false;
    const isFirefox = /firefox/i.test(navigator.userAgent);

    function setTtsStatus(text, state){
      ttsStatus.textContent = "Speech: " + text;
      if (state === "ready") {
        ttsInitBtn.textContent = "Speech Ready ✓";
        ttsInitBtn.classList.remove("primary");
        ttsInitBtn.classList.add("success");
        ttsInitBtn.setAttribute("aria-pressed","true");
        ttsInitBtn.disabled = true;
        speakBtn.disabled = false;
      } else if (state === "locked") {
        ttsInitBtn.textContent = "Enable Speech";
        ttsInitBtn.classList.add("primary");
        ttsInitBtn.classList.remove("success");
        ttsInitBtn.setAttribute("aria-pressed","false");
        ttsInitBtn.disabled = false;
        speakBtn.disabled = true;
      } else if (state === "unsupported") {
        ttsInitBtn.textContent = "Speech Unsupported";
        ttsInitBtn.disabled = true;
        speakBtn.disabled = true;
      } else if (state === "error") {
        ttsInitBtn.textContent = "Speech Error";
        ttsInitBtn.disabled = false;
        speakBtn.disabled = true;
      }
    }

    function populateVoices(){
      voiceSel.innerHTML = "";
      const list = voices.slice().sort((a,b)=>{
        const aj = /ja/i.test(a.lang), bj = /ja/i.test(b.lang);
        if (aj !== bj) return aj ? -1 : 1;
        return (a.name||'').localeCompare(b.name||'');
      });
      list.forEach(v=>{
        const opt = document.createElement('option');
        opt.value = v.name;
        opt.textContent = v.name + (v.lang? " ("+v.lang+")": "");
        voiceSel.appendChild(opt);
      });
    }

    function tryLoadVoices(){
      const v = window.speechSynthesis.getVoices();
      if (!v || v.length === 0) return false;
      voices = v;
      voicesReady = true;
      populateVoices();
      return true;
    }

    // Lightweight audio context nudge to satisfy autoplay policies
    function unlockAudioGesture(){
      try{
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        const ctx = new Ctx();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        gain.gain.value = 0.001;
        osc.frequency.value = 880;
        osc.connect(gain).connect(ctx.destination);
        osc.start();
        setTimeout(()=>{ osc.stop(); ctx.close(); }, 80);
      }catch{}
    }

    // Empty utterance to unlock speech; helps Firefox
    function unlockSynth(cb){
      try {
        const u = new SpeechSynthesisUtterance('\u200b');
        u.volume = 0.01; u.rate = 1; u.pitch = 1; u.lang = 'ja-JP';
        u.onend = ()=> cb && cb();
        speechSynthesis.speak(u);
      } catch { cb && cb(); }
    }

    window.speechSynthesis.onvoiceschanged = ()=>{
      if (tryLoadVoices()) setTtsStatus("Ready", "ready");
    };

    ttsInitBtn.addEventListener('click', ()=>{
      if (!('speechSynthesis' in window)) return setTtsStatus("Not available in this browser", "unsupported");
      unlockAudioGesture();
      let tries = 0;
      const maxTries = isFirefox ? 20 : 10; // poll longer on FF
      const poll = setInterval(()=>{
        tries++;
        if (tryLoadVoices()) { clearInterval(poll); setTtsStatus("Ready", "ready"); }
        if (tries >= maxTries) {
          clearInterval(poll);
          // Even without a list, FF can speak if lang is set
          setTtsStatus(voicesReady ? "Ready" : "Ready (no list; using ja-JP)", "ready");
        }
      }, 150);
      unlockSynth(()=> setTimeout(()=>{ if (tryLoadVoices()) setTtsStatus("Ready", "ready"); }, 120));
    });

    function getSelectedVoice(){
      const sel = voiceSel.value;
      const list = window.speechSynthesis.getVoices();
      return list.find(v => v.name === sel) ||
             list.find(v => /ja/i.test(v.lang)) ||
             list[0] || null;
    }

    function speak(text){
      if (!text) return;
      if (!('speechSynthesis' in window)) return setTtsStatus("Not available", "unsupported");
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      const v = getSelectedVoice();
      if (v) { u.voice = v; u.lang = v.lang || 'ja-JP'; }
      else   { u.lang = 'ja-JP'; } // FF fallback when list empty
      u.rate = 1; u.pitch = 1; u.volume = 1;
      u.onerror = ()=> setTtsStatus("Playback error", "error");
      try { if (!isFirefox) window.speechSynthesis.resume(); } catch {}
      window.speechSynthesis.speak(u);
    }

    speakBtn.addEventListener('click', ()=> speak(input.value));

    // Initial states
    setTtsStatus("Locked (tap Enable)", "locked");
    update();
  </script>
</body>
</html>
