<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="theme-color" content="#0b0f14" />
    <title>Romaji ‚Üí „Å≤„Çâ„Åå„Å™ / „Ç´„Çø„Ç´„Éä</title>
    <style>
      :root {
        --bg: #0b0f14;
        --panel: #111824;
        --muted: #152033;
        --text: #e8eef7;
        --sub: #a8b3c5;
        --acc: #7aa2ff;
        --ok: #22c55e;
        --warn: #f59e0b;
        --danger: #ef4444;
        --radius: 16px;
        --pad: 16px;
        --tap: 44px;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font:
          16px/1.5 system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          'Noto Sans',
          sans-serif;
      }
      header {
        padding: 20px var(--pad) 10px;
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }
      header h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 700;
      }
      header .badge {
        background: var(--muted);
        padding: 6px 10px;
        border-radius: 999px;
        color: var(--sub);
        font-size: 12px;
      }
      .container {
        padding: var(--pad);
        max-width: 900px;
        margin: 0 auto;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        margin: 0.5rem 0;
      }
      textarea {
        width: 100%;
        min-height: 260px;
        background: #0a1220;
        color: var(--text);
        border: 1px solid #1f2a3a;
        border-radius: 12px;
        padding: 14px;
        font-size: 18px;
        line-height: 1.7;
        resize: vertical;
      }
      button,
      select {
        appearance: none;
        border: 1px solid #293241;
        background: #0f1725;
        color: var(--text);
        padding: 10px 14px;
        border-radius: 12px;
        font-weight: 600;
        min-height: var(--tap);
      }
      button.primary {
        background: linear-gradient(180deg, #486bff, #3a57d6);
        border: none;
      }
      button.success {
        background: linear-gradient(180deg, #16a34a, #15803d);
        border: none;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .hint {
        color: var(--sub);
        font-size: 12px;
      }
      .status {
        font-size: 12px;
        color: var(--sub);
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Romaji ‚Üí „Å≤„Çâ„Åå„Å™ / „Ç´„Çø„Ç´„Éä</h1>
      <span class="badge">Firefox TTS Patch</span>
    </header>
    <div class="container">
      <p>Inline conversion (same textbox). TTS included</p>

      <div class="row">
        <label for="mode" class="hint">Mode</label>
        <select id="mode" aria-label="Conversion mode">
          <option value="hiragana">Hiragana</option>
          <option value="katakana">Katakana</option>
          <option value="none">None</option>
        </select>
        <button id="ttsInit" class="primary" aria-pressed="false" aria-label="Enable speech">
          Enable Speech
        </button>
        <button id="speak" aria-label="Speak" disabled>Speak</button>
        <select id="voice" aria-label="Voice" style="max-width: 50ch"></select>
      </div>
      <div class="status" id="ttsStatus">Speech: Locked (tap Enable)</div>

      <textarea id="input" class="jp-ime" placeholder="Type romaji here..."></textarea>
      <script type="module" src="/js/ime-glue.js"></script>
      <div class="hint">
        Tips: double consonants ‚Üí „Å£, 'n' before non-vowel ‚Üí „Çì, digraphs like sha/kyo/chu
        supported.
      </div>
    </div>
    <script>
      const input = document.getElementById('input');
      const mode = document.getElementById('mode');
      const speakBtn = document.getElementById('speak');
      const ttsInitBtn = document.getElementById('ttsInit');
      const voiceSel = document.getElementById('voice');
      const ttsStatus = document.getElementById('ttsStatus');

      // =============================================================
      // INLINE CONVERSION (Caret-safe + IME-safe)
      // =============================================================
      const MAP = {
        kya: '„Åç„ÇÉ',
        kyu: '„Åç„ÇÖ',
        kyo: '„Åç„Çá',
        gya: '„Åé„ÇÉ',
        gyu: '„Åé„ÇÖ',
        gyo: '„Åé„Çá',
        sha: '„Åó„ÇÉ',
        shu: '„Åó„ÇÖ',
        sho: '„Åó„Çá',
        ja: '„Åò„ÇÉ',
        ju: '„Åò„ÇÖ',
        jo: '„Åò„Çá',
        cha: '„Å°„ÇÉ',
        chu: '„Å°„ÇÖ',
        cho: '„Å°„Çá',
        nya: '„Å´„ÇÉ',
        nyu: '„Å´„ÇÖ',
        nyo: '„Å´„Çá',
        hya: '„Å≤„ÇÉ',
        hyu: '„Å≤„ÇÖ',
        hyo: '„Å≤„Çá',
        mya: '„Åø„ÇÉ',
        myu: '„Åø„ÇÖ',
        myo: '„Åø„Çá',
        rya: '„Çä„ÇÉ',
        ryu: '„Çä„ÇÖ',
        ryo: '„Çä„Çá',
        bya: '„Å≥„ÇÉ',
        byu: '„Å≥„ÇÖ',
        byo: '„Å≥„Çá',
        pya: '„Å¥„ÇÉ',
        pyu: '„Å¥„ÇÖ',
        pyo: '„Å¥„Çá',
        shi: '„Åó',
        chi: '„Å°',
        tsu: '„Å§',
        fu: '„Åµ',
        ji: '„Åò',
        di: '„Å¢',
        du: '„Å•',
        a: '„ÅÇ',
        i: '„ÅÑ',
        u: '„ÅÜ',
        e: '„Åà',
        o: '„Åä',
        ka: '„Åã',
        ki: '„Åç',
        ku: '„Åè',
        ke: '„Åë',
        ko: '„Åì',
        ga: '„Åå',
        gi: '„Åé',
        gu: '„Åê',
        ge: '„Åí',
        go: '„Åî',
        sa: '„Åï',
        si: '„Åó',
        su: '„Åô',
        se: '„Åõ',
        so: '„Åù',
        za: '„Åñ',
        zi: '„Åò',
        zu: '„Åö',
        ze: '„Åú',
        zo: '„Åû',
        ta: '„Åü',
        ti: '„Å°',
        tu: '„Å§',
        te: '„Å¶',
        to: '„Å®',
        da: '„Å†',
        de: '„Åß',
        do: '„Å©',
        na: '„Å™',
        ni: '„Å´',
        nu: '„Å¨',
        ne: '„Å≠',
        no: '„ÅÆ',
        ha: '„ÅØ',
        hi: '„Å≤',
        he: '„Å∏',
        ho: '„Åª',
        ba: '„Å∞',
        bi: '„Å≥',
        bu: '„Å∂',
        be: '„Åπ',
        bo: '„Åº',
        pa: '„Å±',
        pi: '„Å¥',
        pu: '„Å∑',
        pe: '„Å∫',
        po: '„ÅΩ',
        ma: '„Åæ',
        mi: '„Åø',
        mu: '„ÇÄ',
        me: '„ÇÅ',
        mo: '„ÇÇ',
        ya: '„ÇÑ',
        yu: '„ÇÜ',
        yo: '„Çà',
        ra: '„Çâ',
        ri: '„Çä',
        ru: '„Çã',
        re: '„Çå',
        ro: '„Çç',
        wa: '„Çè',
        wi: '„ÅÜ„ÅÉ',
        we: '„ÅÜ„Åá',
        wo: '„Çí',
        fa: '„Åµ„ÅÅ',
        fi: '„Åµ„ÅÉ',
        fe: '„Åµ„Åá',
        fo: '„Åµ„Åâ',
        va: '„Çî„ÅÅ',
        vi: '„Çî„ÅÉ',
        vu: '„Çî',
        ve: '„Çî„Åá',
        vo: '„Çî„Åâ',
        xa: '„ÅÅ',
        xi: '„ÅÉ',
        xu: '„ÅÖ',
        xe: '„Åá',
        xo: '„Åâ',
        xya: '„ÇÉ',
        xyu: '„ÇÖ',
        xyo: '„Çá',
        xtu: '„Å£',
        ltu: '„Å£',
        n: '„Çì',
      };
      const VOWELS = new Set(['a', 'i', 'u', 'e', 'o']);
      function isLetter(c) {
        return /^[a-z]$/i.test(c);
      }
      function isConsonant(c) {
        return isLetter(c) && !VOWELS.has(c.toLowerCase());
      }

      function romajiToHiragana(s) {
        s = (s || '').toLowerCase();
        let out = '';
        let i = 0;
        while (i < s.length) {
          const c = s[i];
          if (!/[a-z]/.test(c)) {
            out += s[i++];
            continue;
          }
          if (i + 1 < s.length && s[i] === s[i + 1] && isConsonant(s[i]) && s[i] !== 'n') {
            out += '„Å£';
            i += 1;
            continue;
          }
          if (c === 'n') {
            const nxt = s[i + 1];
            if (!nxt || (!VOWELS.has(nxt) && nxt !== 'y')) {
              out += '„Çì';
              i += 1;
              continue;
            }
          }
          const tri = s.slice(i, i + 3);
          const bi = s.slice(i, i + 2);
          const si = s.slice(i, i + 1);
          if (MAP[tri]) {
            out += MAP[tri];
            i += 3;
            continue;
          }
          if (MAP[bi]) {
            out += MAP[bi];
            i += 2;
            continue;
          }
          if (MAP[si]) {
            out += MAP[si];
            i += 1;
            continue;
          }
          out += s[i];
          i += 1;
        }
        return out;
      }

      function toKatakanaFromHiragana(h) {
        return h.replace(/[„ÅÅ-„Çñ]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) + 0x60));
      }

      let composing = false;
      function convertAll(text, m) {
        if (m === 'none') return text;
        const hira = romajiToHiragana(text);
        return m === 'katakana' ? toKatakanaFromHiragana(hira) : hira;
      }
      function convertPrefixLen(text, caret, m) {
        const prefix = text.slice(0, caret);
        return convertAll(prefix, m).length;
      }
      function update() {
        const m = mode.value;
        const before = input.value;
        const start = input.selectionStart,
          end = input.selectionEnd;

        const converted = convertAll(before, m);
        const newStart = convertPrefixLen(before, start, m);
        const newEnd = convertPrefixLen(before, end, m);

        if (before !== converted) input.value = converted;
        try {
          input.setSelectionRange(newStart, newEnd);
        } catch {}

        // ‚úÖ Just call the glue API if it exists. No else branch.
        if (window.IME && typeof window.IME.requestSuggest === 'function') {
          window.IME.requestSuggest(input.value);
        }
      }

      // üö´ DELETE this ‚Äî it causes recursion
      // window.IME = window.IME || {};
      // window.IME.requestSuggest = (text) => {
      //   window.IME && window.IME.requestSuggest(input.value);
      // };

      // IME composition guards (keep)
      input.addEventListener('compositionstart', () => {
        composing = true;
      });
      input.addEventListener('compositionend', () => {
        composing = false;
        update();
      });

      input.addEventListener('input', () => {
        if (!composing) update();
      });
      input.addEventListener('paste', () => {
        setTimeout(() => {
          if (!composing) update();
        }, 0);
      });
      mode.addEventListener('change', update);

      // =============================================================
      // TEXT-TO-SPEECH (Firefox-friendly unlock + fallback)
      // =============================================================
      let voices = [];
      let voicesReady = false;
      const isFirefox = /firefox/i.test(navigator.userAgent);

      function setTtsStatus(text, state) {
        ttsStatus.textContent = 'Speech: ' + text;
        if (state === 'ready') {
          ttsInitBtn.textContent = 'Speech Ready ‚úì';
          ttsInitBtn.classList.remove('primary');
          ttsInitBtn.classList.add('success');
          ttsInitBtn.setAttribute('aria-pressed', 'true');
          ttsInitBtn.disabled = true;
          speakBtn.disabled = false;
        } else if (state === 'locked') {
          ttsInitBtn.textContent = 'Enable Speech';
          ttsInitBtn.classList.add('primary');
          ttsInitBtn.classList.remove('success');
          ttsInitBtn.setAttribute('aria-pressed', 'false');
          ttsInitBtn.disabled = false;
          speakBtn.disabled = true;
        } else if (state === 'unsupported') {
          ttsInitBtn.textContent = 'Speech Unsupported';
          ttsInitBtn.disabled = true;
          speakBtn.disabled = true;
        } else if (state === 'error') {
          ttsInitBtn.textContent = 'Speech Error';
          ttsInitBtn.disabled = false;
          speakBtn.disabled = true;
        }
      }

      function populateVoices() {
        voiceSel.innerHTML = '';
        const list = voices.slice().sort((a, b) => {
          const aj = /ja/i.test(a.lang),
            bj = /ja/i.test(b.lang);
          if (aj !== bj) return aj ? -1 : 1;
          return (a.name || '').localeCompare(b.name || '');
        });
        list.forEach((v) => {
          const opt = document.createElement('option');
          opt.value = v.name;
          opt.textContent = v.name + (v.lang ? ' (' + v.lang + ')' : '');
          voiceSel.appendChild(opt);
        });
      }

      function tryLoadVoices() {
        const v = window.speechSynthesis.getVoices();
        if (!v || v.length === 0) return false;
        voices = v;
        voicesReady = true;
        populateVoices();
        return true;
      }

      // Lightweight audio context nudge to satisfy autoplay policies
      function unlockAudioGesture() {
        try {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          if (!Ctx) return;
          const ctx = new Ctx();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          gain.gain.value = 0.001;
          osc.frequency.value = 880;
          osc.connect(gain).connect(ctx.destination);
          osc.start();
          setTimeout(() => {
            osc.stop();
            ctx.close();
          }, 80);
        } catch {}
      }

      // Empty utterance to unlock speech; helps Firefox
      function unlockSynth(cb) {
        try {
          const u = new SpeechSynthesisUtterance('\u200b');
          u.volume = 0.01;
          u.rate = 1;
          u.pitch = 1;
          u.lang = 'ja-JP';
          u.onend = () => cb && cb();
          speechSynthesis.speak(u);
        } catch {
          cb && cb();
        }
      }

      window.speechSynthesis.onvoiceschanged = () => {
        if (tryLoadVoices()) setTtsStatus('Ready', 'ready');
      };

      ttsInitBtn.addEventListener('click', () => {
        if (!('speechSynthesis' in window))
          return setTtsStatus('Not available in this browser', 'unsupported');
        unlockAudioGesture();
        let tries = 0;
        const maxTries = isFirefox ? 20 : 10; // poll longer on FF
        const poll = setInterval(() => {
          tries++;
          if (tryLoadVoices()) {
            clearInterval(poll);
            setTtsStatus('Ready', 'ready');
          }
          if (tries >= maxTries) {
            clearInterval(poll);
            // Even without a list, FF can speak if lang is set
            setTtsStatus(voicesReady ? 'Ready' : 'Ready (no list; using ja-JP)', 'ready');
          }
        }, 150);
        unlockSynth(() =>
          setTimeout(() => {
            if (tryLoadVoices()) setTtsStatus('Ready', 'ready');
          }, 120)
        );
      });

      function getSelectedVoice() {
        const sel = voiceSel.value;
        const list = window.speechSynthesis.getVoices();
        return (
          list.find((v) => v.name === sel) ||
          list.find((v) => /ja/i.test(v.lang)) ||
          list[0] ||
          null
        );
      }

      function speak(text) {
        if (!text) return;
        if (!('speechSynthesis' in window)) return setTtsStatus('Not available', 'unsupported');
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        const v = getSelectedVoice();
        if (v) {
          u.voice = v;
          u.lang = v.lang || 'ja-JP';
        } else {
          u.lang = 'ja-JP';
        } // FF fallback when list empty
        u.rate = 1;
        u.pitch = 1;
        u.volume = 1;
        u.onerror = () => setTtsStatus('Playback error', 'error');
        try {
          if (!isFirefox) window.speechSynthesis.resume();
        } catch {}
        window.speechSynthesis.speak(u);
      }

      speakBtn.addEventListener('click', () => speak(input.value));

      // Initial states
      setTtsStatus('Locked (tap Enable)', 'locked');
      update();
    </script>
  </body>
</html>
